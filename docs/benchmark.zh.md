## 基准测试

通过与 JSON、ProtoBuf(protobufjs) 在 JavaScript 环境上对不同数据类型的编解码的耗时进行了对比。
对于 JSON 的编码，是先将数据编码成字符串，再将字符串编码为 utf8 二进制数据。解码则是将二进制数据通过 utf-8 解码，然后解析字符串 JSON
对于 ProtoBuf，由于它不支持直接定义数组类型，在测试中定义了一个只有一个字段的对象，这个对象的类型为 repeat 类型。也就是说，在下面的测试中，JSON 和 JBOD 处理的如果是 10000 个 8 的数组，那么 ProtoBuf 处理的则是 1 个带有 10000 个 8 的数组的对象。

### 运行项目中的基准测试

为了获得更精准的结果，项目中使用了 Deno 进行基准测试。

- 运行 `deno task benchmark`，测试结果输出到 benchmark/dist/result.json
- 运行 `deno task bench-ui`, 启动 web 服务器，查看测试结果

### 不同数据类型的编解码对比

<img src="./docs/bench/cp.png"/>
上图的基准测试中，是对一个数组进行编解码，其中数组的值是相同的，每组测试的数据如下

| 名称                   | 数据                         |
| ---------------------- | ---------------------------- |
| int32: 8\*10000        | 10000 个值为 8 的数组        |
| int32: -1234567\*10000 | 10000 个值为 -1234567 的数组 |
| double \*10000         | 10000 个值为 4 / 7 的数组    |
| boolean \*10000        | 10000 个值为 true 的数组     |
| string \*1000          | 1000 个值为 "中文 abc"的数组 |

object list \*1000 ：1000 个下面的对象

```
{
  disabled: false,
  count: 100837,
  name: "Documentation",
  dataStamp: 4 / 7,
  id: 876,
}
```

**结论：**
对于整数类型，可以看到影响 JSON 编解码的的时间是字符串长度，在对浮点数据处理是尤其耗时。

为什么 JBOD 处理对象怎么慢？\
JBOD 在处理对象时，80% 的耗时主要在处理对象的键(字符串)

那为什么 protobufjs 对对象类型编界码与 JSON 差不多？\
ProtoBuf 的键通过 id 进行了映射，键的编解码实际是对整数(varints) 进行编解码，并且 ProtoBuf 的对象是预先定义好的，是固定的数据类型，具体可以往下看 Struct 编解码

#### Struct 编解码对比

<img src="./docs/bench/struct.png"/>
上图是仍然是对1000长度的对象数组进行编解码，可以看到，由于不需要编码字符串键，对于相同的数据，Struct 相比 any 类型有了很大的提升
